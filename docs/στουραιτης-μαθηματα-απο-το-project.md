# Το singleton pattern είναι εξαιρετικά χρήσιμο
Ένα από τα προβλήματα με το tkinter είναι ότι δεν μπορείς εύκολα να δημιουργήσεις αντικείμενα σε πολλά σημεία του κώδικα και να τα κάνεις import επειδή δεν προλαβαίνουν να αρχικοποιηθούν σωστά. Άρα για να έχεις πρόσβαση στα δεδομένα τους, ή πρέπει να έχεις ένα dictionary που κρατάει όλα τα αρχικοποιημένα αντικείμενα (κακή ιδέα λόγο type checking και περίεργων bugs) ή να προγραμματίσεις τα classes ώστε να μπορούν να αρχικοποιούν μόνο 1 αντικείμενο. Έτσι γλυτώνεις και την χρήση των εσωτερικών λειτουργιών του tkinter που θέλουν και πολύ συνήθεια, και δεν δουλεύουν όπως θες πολλές φορές.

# Προσοχή στο multiple inheritance
Μπορεί να είναι βολικό, ειδικά στο φιλτράρισμα των components και ως δήλωση τύπων, αλλά θέλει προσοχή επειδή μπορούν να δημιουργηθούν σημαντικά bugs

# Hotkeys
Πλέον το project έχει ξεπεράσει τις 3000 γραμμές κώδικα και ενώ είμαι αυτός που το έγραψε, δυσκολεύομαι να θυμηθώ που είναι τι με τις συνήθεις μεθόδους όπως scrolling. Αναζήτηση κειμένου, gotos και άλλα εργαλεία που δίνουν τα IDE είναι πολύ σημαντικά. 

# Πρώτα τα παιδιά, μετά οι γονείς.
Εάν ξεκινήσει η υλοποίηση από την κεντρική μονάδα, τότε υπάρχει η περίπτωση να την σχεδιάσουμε με τρόπο που κάνει υπερβολικά πολλά πράγματα. Εάν ξεκινήσουμε από τα παιδιά που έχουν λιγότερες απαιτήσεις αλλά περισσότερα dependencies, τότε η αλυσίδα των dependencies θα δημιουργηθεί αυτόματα και κάθε μονάδα θα κάνει ακριβώς αυτό που πρέπει.

# Είναι σημαντικό να βρίσκουμε τρόπους να μειώνουμε τις γραμμές κώδικα με τρόπο που δεν μειώνει την περιγραφικότητα των ονομασιών.
Πχ, έστω ότι έχουμε αποθηκεύσει τις ρυθμίσεις σε ένα json αρχείο και το διαβάζουμε στην python με τη μορφή dictionary. Κάθε φορά που χρειαζόμαστε πληροφορία, πρέπει να γράψουμε settings_dictionary["setting_group_1"]["setting1"]. Μπορεί να είναι περιγραφικό, αλλά γίνεται υπερβολικά κουραστικό και στην ανάγνωση και στην πληκτρολόγιση. Επίσης κάνει το κείμενο πολύ άνισο. Είναι καλύτερα να φτιάξουμε ένα class ώστε να ανακτούμε τις πληροφορίες με την μορφή SettingsGroup1.setting1

# Το πιο σημαντικό optimization είναι το caching. Τα υπόλοιπα καλύτερα να γίνουν στο τέλος και δεν είναι σίγουρο ότι θα χρειαστούν.
Όταν έχεις 10 μονάδες που χρειάζονται πρόσβαση στα ίδια δεδομένα, 

# Τα logs είναι πιο σημαντικά από τα σχόλια κατα την υλοποίηση
Πολλά πράγματα αλλάζουν κατα την διάρκεια της υλοποίησης οπότε ο σχολιασμός πρέπει να είναι μετριασμένος και με σκοπό να σου υπενθυμίσει τι πρέπει να κάνεις. Τα logs από την άλλη βοηθούν στην λύση προβλημάτων και έχουν αρκετά επεξηγηματικό χαρακτήρα ώστε να θυμάσαι τι κάνει η κάθε συνάρτηση ακόμα και αν περάσει λίγος καιρός. Επίσης μπορείς να κάνεις αναζήτηση κειμένου σε όλο το directory και να δεις από που ήρθε το log, κάτι που δεν μπορεί να γίνει με σχόλια.

# Σχεδόν πάντα υπάρχει καλύτερος έτοιμος τρόπος
Ήταν ένα σοβαρό πρόβλημα στην αρχή που δεν είχα συνηθίσει το tkinter και προσπαθούσα να κάνω τις μονάδες να επικοινωνούν. Βέβαια μετά από κάποιο σημείο, τα builtins δεν λύνουν όλα τα προβλήματα (η δημιουργούν νέα και πιο περίπλοκα) και πρέπει να υλοποιήσεις τις δικές σου μεθόδους.

# Η δήλωση τύπων προλαμβάνει και γλυτώνει bugs
Μπορεί να είναι κουραστικό να πρέπει να ελεγχθούν όλες οι μεταβλητές, αλλά μετά από πολλές ώρες συνειδητοποίησα ότι και κάνει πιο εύκολη την αναζήτηση σφαλμάτων, και σε αναγκάζει να οργανώσεις τον κώδικα καλύτερα. Είναι ακόμα πιο σημαντικό όταν υπάρχει μια κεντρική αρχή που ρυθμίζει τα πάντα, και τα δεδομένα που πρέπει να διαχειριστεί είναι πάσης φύσεως (Any | None).

# Το autocompletion LLM bot είναι καλό για αρχή να σου γράφει boilerplate
Μετά το boilerplate, περισσότερες από τις μισές γραμμές κώδικα που προτίνει ή δεν υφίστανται, ή δεν κάνουν αυτό που θες. Έφτασα στο σημείο να ξοδεύω περισσότερο χρόνο σβήνοντας τις προτάσεις του bot επειδή πάτησα καταλάθος tab, παρά να σκέφτομαι την υλοποίηση. Και δεν είναι μόνο ο χαμένος χρόνος, αλλά κυρίως η απόσπαση της προσοχής που δημιουργεί εκνευρισμό και σε κάνει να ξεχνάς αυτό που ήθελες να κάνεις.

# Η Python είναι αργή για επεξεργασία δεδομένων
Αν και ξέφυγα από τα όρια της εργασίας, κάνοντας performance testing σε 600,000 εγγραφές, το μάθημα ήταν σημαντικό. Αν και έχω διαχειριστεί δεδομένα στο παρελθόν, δεν είχα εμπειρία με GUI και χρησιμοποιούσα Pandas σε δεδομένα από API, που δεν ήταν τόσο μεγάλος όγκος.

# Εάν τα δεδομένα είναι συνάρτηση χρόνου, δεν υπάρχει λόγος να μην γίνει caching
Συγκριτικά με τους πελάτες, τα ραντεβού ήταν πολύ εύκολα διαχειρίσημα. Η ιδέα να τα χωρίσω σε περιόδους ήρθε πολύ φυσικά στο μυαλό μου και πορεύτηκα εξαρχης με βάση αυτό. Για τους πελάτες όμως η λύση δεν ήταν προφανής.

# Ο σχεδιασμός των interface είναι πιο σημαντικός από τον σχεδιασμό των class.
Αν και η python δεν κάνει τέτοιο διαχωρισμό, σε απλά ελληνικά, το πως θα γίνεται η διαχείριση δεδομένων από τα αντικείμενα αλλάζει διαρκώς. Το πως θα ενημερώνονται στις μεταβολές όμως ήταν σταθερό από την πρώτη στιγμή.

# Τα IDE δεν είναι μόνο για autocompletion.
Όσο μεγαλώνει το codebase, τόσο πιο σημαντική γίνεται η γρήγορη πλοήγηση. Από την 5η μέρα και μετά το πρόγραμμα ήταν πολύ μεγάλο για να θυμάμαι που είναι τι. Ήξερα που είναι το κάθε class, αλλά δεν μπορούσα να θυμάμαι με τι επικοινωνεί, σε πια μέθοδο κάνει τον x, y υπολογισμό, κλπ. Για παράδειγμα, κάποια view components έχουν όλο τον κώδικα στις μεθόδους .__ init __ και .update. Άλλα που έχουν περισσότερους υπολογισμούς, έχουν την .draw, ή άλλες βοηθητικές συναρτήσεις που κάνουν μικρούς σημαντικούς υπολογισμούς. Οπότε ο κύριος τρόπος πλοήγησης ήταν

- File Search. Ειδικά σε συνδιασμό με τα logs. Εάν κάνεις αναζήτηση του κειμένου θα δεις και πια συνάρτηση το εγραψε. Επίσης μπορείς πολύ γρήγορα να βρεις ποια αντικείμενα χρησιμοποιούν κάποια προβληματική συνάρτηση. 
- Definition search. Πηγαίνεις αυτόματα από συνάρτηση σε συνάρτηση μέχρι να βρεις τον πατέρα. Ιδιαίτερα χρήσιμο στην ιχνηλάτιση προβληματικών import.
- Μαζική αλλαγή κειμένου. Αυτονόητο.
- Αναζήτηση γραμμής. Είναι ιδιαίτερα κουραστικό να κάνεις scroll σε κάθε exception.

Επίσης
- Static type checking. Το πόσα bugs μου γλύτωσε δεν περιγράφεται.
- Αυτόματο format. 
- Debugger. 
