# Οσο πιο αναλυτικό το πλάνο εξαρχής, τόσο πιο εύκολη η υλοποίηση
Μπορεί να είναι προφανές, αλλά προσωπικά το μεγαλύτερο πρόβλημα ήταν η απόσπαση της προσοχής μεταξύ του να συνειδητοποιήσω τι πρέπει να κάνω και να βρω την πληροφορία του πως θα το υλοποιήσω. Απλοί αλγόριθμοι έπαιρναν ολόκληρες ώρες και ήταν γεμάτοι λάθη λόγω του εκνευρισμού που μου δημιουργούσε αυτό το πέρα δώθε.

# Απλοποίηση, απλοποίηση, και άλλη λίγη απλοποίηση ακόμα.
Όταν η συνάρτηση ξεπερνάει τις 10 γραμμές, συνήθως σημαίνει ότι κάνει υπερβολικά πολλούς υπολογισμούς, και πρέπει να χωριστεί σε κομμάτια. Επίσης το μεγαλύτερο κομμάτι της υλοποίησης συνήθως πρέπει να μεταφερθεί σε τελείως διαφορετικό κομμάτι του κώδικα. Για παράδειγμα έκανα διαχείρηση δεδομένων καθώς έγραφα κώδικα για το GUI και έπαιρνε πολύ ώρα να συνειδητοποιήσω ότι αυτές οι διαδικασίες πρέπει να μπουν στον κώδικα του μοντέλου (φιλτραρίσματα σε λίστες, συγκρίσεις μεταξύ αντικειμένων κλπ)

# Προσοχή στο multiple inheritance
Την στιγμή που αποφάσισα να φτιάξω μια αλυσίδα από χαρακτηριστικά και να τα συνδέσω με subclassing στα components, η κατάσταση έγινε χαοτική, και πολλά από τα superclasses στην πράξη δεν πρόσεφεραν τίποτα ουσιστικό. Απλά έπιαναν χώρο στο κείμενο και με κούραζαν με το υπερβολικό scrolling.

# Hotkeys
Από τις 200 σειρές και μετά το scrolling παίρνει περισσότερη ώρα από την πρόσθεση μιας σειράς κώδικα. Όσο πιο γρήγορη αναζήτηση μπορείς να κάνεις με τα εργαλεία του IDE, τόσο πιο καθαρό μυαλό θα έχεις μετά από μερικές ώρες. 

# Το GUI είναι μακράν το πιο χρονοβόρο και εκνευριστικό κομμάτι
Ο κύριος λόγος είναι η μεταφορά των δεδομένων μεταξύ των class και των συναρτήσεων. Η πιο εύκολη λύση είναι να αποθηκέυεις το state σε global variables και να φτιάχνεις class properties για τα πάντα. Το πρόβλημα είναι οτι μετά από λίγο το class έχει φτάσει 200 γραμμές και περισσότερα από τα μισά properties αποδείχτηκαν αχρείαστα.

# Πρώτα το γραφιστικό, μετά η λογική
Ίσως η πιο χρονοβόρα πρακτική είναι να γράφεις τον πολύπλοκο κώδικα της λογικής, και να πρέπει να σταματήσεις στο ενδιάμεσο να φτιάξεις ένα γρήγορο GUI να δείς ότι όλα δουλεύουν όπως πρέπει. Ναι γίνεται να ελένξεις κάτι στο terminal, γίνεται να γράψεις και tests, αλλά όταν είσαι τόσο κοντά στην πηγή δεν έχει και πολύ νόημα να μην πιεις νερό. Και μετα σου μένει ενα μισοφτιαγμένο GUI που κατα 99% θα πρέπει να αλλάξεις ριζικά επειδή η προχειροδουλειά στην αρχή σε οδηγεί σε αδιέξοδα

# Καλά τα dictionaries και οι λίστες για μαζική αποθήκευση δεδομένων, αλλά μόλις πας να τα ανακτήσεις...
Το αποτέλεσμα είναι κάπως έτσι 
"self.calculation = static_object + timedelta(minutes=self.list_of_objects[i].duration // self.configuration["dynamic_config_item1"] // 60).totalseconds() "
Μέχρι να το γράψεις, έχεις ξεχάσει τι αποθήκευαν οι δομές δεδομένων. Από την άλλη αν σταματήσεις την περιγραφική ονομασία μεταβλητών, θα πρέπει να θυμάσε τι κάνει το self.a και self.b, που μετά από μερικές ώρες είναι αδύνατο.

# @property συναρτήσεις είναι θεόσταλτες
Είναι πολύ μακρύς ο κώδικας? Χρησιμοποιείς πληροφορίες αποθηκευμένες σε δομές δεδομένων συχνά? Μετέτρεψε τα σε class properties και ξέχνα τα. Σε κάποιες στιγμές, ήθελα να αποφύγω μέχρι και το () του function call, ακόμα και αν δεν έιχε παραμέτρους. Επίσης έτσι γλυτώνεις και την δήλωση 23432 instance properties που κάνουν την __init__ function μεγαλύτερη από μεταπτυχιακή εργασία. Και ενώ ισχύει ότι το να γράφεις 23432 @property μεθόδους πιάνει και αυτό πολύ χώρο, επειδή είναι περιορισμένες σε 2-3 σειρές είναι πολύ πιο εύκολο να καταλάβεις τι κάνουν και να τις προσπεράσεις. Όταν όμως έχεις 200 σειρές __init__ function με δηλώσεις, logs, υπολογισμούς και δομές επανάληψης, δεν είναι και τόσο εύκολο να δεις ξεκάθαρα που είναι το bug.

# Τα ORM είναι θεόσταλτα
Δεν είναι το θέμα να αποφύγεις την SQL. Είναι να αποφύγεις τα bugs και το υπερβολικό templating. Με 2 λέξεις (session.add(Object)) έχεις γλυτώσει κάτι του στιλ f"INSERT INTO ObjectTable (..., ..., ..) VALUES ({property1}, {property2} ....". Είναι τόσο εύκολο που κάνει τις βάσεις δεδομένων πιο εύκολες και απο αποθήκευση σε plaintext.

# Κακό πλάνο οδηγεί σε υπερβολική χρήση του επεξεργαστή, που σημαίνει αργό πρόγραμμα
Ο υπολογιστής βαρέθηκε να κάνει αχρείαστες ανανεώσεις των δεδομένων στα components. Κάποια στιγμή λες, "έλα μωρέ δεν πειράζει, ας προγραμματίσω το parent component να αναγκάζει όλα τα παιδιά του να κάνουν refresh κάθε φορά που κουνιέται το ποντίκι. Δυστυχώς φαίνεται πως θέλει πολύ εμπειρία για να στήσεις το πρόγραμμα με τρόπο που να περιορίζει τις ανανεώσεις δεδομένων, ακόμα και αν εξ αρχής το έχεις κατα νου.

# Πρώτα κώδικας μετά σχόλια
Κακά τα ψέματα, αν και τα σχόλια είναι το μέλλον του κώδικα, στα αρχικά στάδια της υλοποίησης, ότι και να σχολιάσεις κατα πάσα πιθανότητα θα αλλάξει.

# Πάντα υπάρχει καλύτερος έτοιμος τρόπος
Η πιθανότητα να σκεφτείς κάτι που δεν έχει σκεφτεί κάποιος πιο έξυπνος από εσένα τίνει προς το μηδέν. Και την στιγμή που θα βρεις την εναλλακτική λύση από αυτό που προσπαθούσες να υλοποιήσεις από το 0, θα αισθανθείς και ορισμένα ενδιαφέροντα συναισθήματα που κινδυνέυουν να σε μετατρέψουν σε meme.

# Χωρίς type hinting, το χάος
Όχι μόνο βοηθάνε το IDE να σου πει τι να κάνεις, αλλά σου γλυτώνουν ένα σωρό bugs.

# Το autocompletion LLM bot είναι καλό για αρχή να σου γράφει boilerplate
Μετά το boilerplate, περισσότερες από τις μισές γραμμές κώδικα που προτίνει ή δεν υφίστανται, ή δεν κάνουν αυτό που θες. Έφτασα στο σημείο να ξοδεύω περισσότερο χρόνο σβήνοντας τις προτάσεις του bot επειδή πάτησα καταλάθος tab, παρά να σκέφτομαι την υλοποίηση. Και δεν είναι μόνο ο χαμένος χρόνος, αλλά κυρίως η απόσπαση της προσοχής που δημιουργεί εκνευρισμό και σε κάνει να ξεχνάς αυτό που ήθελες να κάνεις.
